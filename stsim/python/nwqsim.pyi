from __future__ import annotations

from enum import Enum
from typing import Any, Sequence, overload


class SimType(Enum):
    SV: SimType
    DM: SimType
    STAB: SimType


class CircuitMetrics:
    depth: int
    one_q_gates: int
    two_q_gates: int
    gate_density: float
    retention_lifespan: float
    measurement_density: float
    entanglement_variance: float


class Circuit:
    def __init__(self, num_qubits: int) -> None: ...
    def num_qubits(self) -> int: ...
    def num_gates(self) -> int: ...
    def is_empty(self) -> bool: ...
    @overload
    def reset(self) -> Circuit: ...
    @overload
    def reset(self, qubit: int) -> Circuit: ...
    def clear(self) -> Circuit: ...
    def to_string(self) -> str: ...
    def metrics(self) -> CircuitMetrics: ...
    def print_metrics(self) -> None: ...
    def append_stim_file(self, path: str) -> Circuit: ...
    def append_stim_text(self, text: str) -> Circuit: ...
    def measure_all(self, shots: int) -> Circuit: ...
    def mod_noise(self, operation: str, noise_model: str, value: float, qubits: Sequence[int]) -> Circuit: ...
    def comb(self, qubit: int, phi: float, lam: float, gamma: float) -> Circuit: ...
    def cu(self, theta: float, phi: float, lam: float, gamma: float, control: int, target: int) -> Circuit: ...
    def ccx(self, control_1: int, control_2: int, target: int) -> Circuit: ...
    def cswap(self, control: int, qubit_a: int, qubit_b: int) -> Circuit: ...
    def x(self, qubit: int) -> Circuit: ...
    def y(self, qubit: int) -> Circuit: ...
    def z(self, qubit: int) -> Circuit: ...
    @overload
    def h(self, qubit: int) -> Circuit: ...
    @overload
    def h(self, qubits: Sequence[int]) -> Circuit: ...
    @overload
    def s(self, qubit: int) -> Circuit: ...
    @overload
    def s(self, qubits: Sequence[int]) -> Circuit: ...
    def h_multi(self, qubits: Sequence[int]) -> Circuit: ...
    def s_multi(self, qubits: Sequence[int]) -> Circuit: ...
    def sdg(self, qubit: int) -> Circuit: ...
    def t(self, qubit: int) -> Circuit: ...
    def tdg(self, qubit: int) -> Circuit: ...
    def sx(self, qubit: int) -> Circuit: ...
    def id(self, qubit: int) -> Circuit: ...
    def m(self, qubit: int) -> Circuit: ...
    def reset(self, qubit: int) -> Circuit: ...
    def ri(self, theta: float, qubit: int) -> Circuit: ...
    def rx(self, theta: float, qubit: int) -> Circuit: ...
    def ry(self, theta: float, qubit: int) -> Circuit: ...
    def rz(self, theta: float, qubit: int) -> Circuit: ...
    def p(self, theta: float, qubit: int) -> Circuit: ...
    def delay(self, theta: float, qubit: int) -> Circuit: ...
    def u(self, theta: float, phi: float, lam: float, qubit: int) -> Circuit: ...
    def u3(self, theta: float, phi: float, lam: float, qubit: int) -> Circuit: ...
    def u2(self, phi: float, lam: float, qubit: int) -> Circuit: ...
    def u1(self, theta: float, qubit: int) -> Circuit: ...
    def cx(self, control: int, target: int) -> Circuit: ...
    def cy(self, control: int, target: int) -> Circuit: ...
    def cz(self, control: int, target: int) -> Circuit: ...
    def ch(self, control: int, target: int) -> Circuit: ...
    def cs(self, control: int, target: int) -> Circuit: ...
    def csdg(self, control: int, target: int) -> Circuit: ...
    def ct(self, control: int, target: int) -> Circuit: ...
    def ctdg(self, control: int, target: int) -> Circuit: ...
    def csx(self, control: int, target: int) -> Circuit: ...
    def ecr(self, control: int, target: int) -> Circuit: ...
    def swap(self, control: int, target: int) -> Circuit: ...
    def crx(self, theta: float, control: int, target: int) -> Circuit: ...
    def cry(self, theta: float, control: int, target: int) -> Circuit: ...
    def crz(self, theta: float, control: int, target: int) -> Circuit: ...
    def cp(self, theta: float, control: int, target: int) -> Circuit: ...
    def rxx(self, theta: float, qubit_a: int, qubit_b: int) -> Circuit: ...
    def ryy(self, theta: float, qubit_a: int, qubit_b: int) -> Circuit: ...
    def rzz(self, theta: float, qubit_a: int, qubit_b: int) -> Circuit: ...
    def chan1(self, qubit: int, probabilities: Sequence[float]) -> Circuit: ...
    def chan2(self, target: int, control: int, probabilities: Sequence[float]) -> Circuit: ...
    def dep1(self, qubit: int, param: float) -> Circuit: ...
    def dep2(self, target: int, control: int, param: float) -> Circuit: ...
    def damp(self, qubit: int, param_a: float, param_b: float) -> Circuit: ...
    def t1(self, qubit: int, param: float) -> Circuit: ...
    def t2(self, qubit: int, param: float) -> Circuit: ...
    def exc(self, qubit: int, param: float) -> Circuit: ...


class QuantumState:
    sim_type: SimType
    def reset(self) -> None: ...
    def set_seed(self, seed: int) -> None: ...
    def simulate(self, circuit: Circuit) -> float: ...
    def simulate_batch(self, circuit: Circuit, shots: int) -> tuple[float, list[list[int]]]: ...
    def measure(self, qubit: int) -> int: ...
    def measure_all(self, shots: int) -> list[int]: ...
    def measurement_results(self) -> list[int]: ...
    def print_config(self, backend: str) -> None: ...
    def dump_state(self, path: str) -> None: ...
    def statevector(self) -> Any: ...
    def num_qubits(self) -> int: ...
    @overload
    def expectation_z(self, bits: Sequence[int]) -> float: ...
    @overload
    def expectation_z(self) -> float: ...


def create_state(backend: str, num_qubits: int, method: str) -> QuantumState: ...
def circuit_from_stim_file(path: str, num_qubits: int = -1) -> Circuit: ...
def circuit_from_stim_text(text: str, num_qubits: int = -1) -> Circuit: ...
def available_backends() -> list[str]: ...


class _ConfigModule:
    def set_print_sim_trace(self, value: bool) -> None: ...
    def set_enable_noise(self, value: bool) -> None: ...
    def set_enable_fusion(self, value: bool) -> None: ...
    def set_random_seed(self, value: int) -> None: ...
    def set_tensor_core(self, value: bool) -> None: ...
    def device_noise_file(self, path: str) -> None: ...
    def device_layout_file(self, path: str) -> None: ...


config: _ConfigModule
__version__: str
